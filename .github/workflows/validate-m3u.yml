name: Validate M3U Links

on:
  workflow_dispatch:
  push:
    branches:
      - master

jobs:
  validate-links:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'


      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: pip install requests

      - name: Validate all links in M3U files
        run: |
          import glob
          import re
          import requests
          import sys
          from concurrent.futures import ThreadPoolExecutor, as_completed

          m3u_files = glob.glob('**/*.m3u', recursive=True)
          url_pattern = re.compile(r'^(https?://[^\s]+)$', re.MULTILINE)
          failed = False
          link_checks = []
          url_to_file = {}


          import time

          def check_url(url, m3u, max_retries=3, delay=2):
              tries = 0
              while tries < max_retries:
                  try:
                      r = requests.head(url, timeout=10, allow_redirects=True)
                      # Retry on 404 only
                      if r.status_code == 404:
                          tries += 1
                          if tries < max_retries:
                              time.sleep(delay)
                              continue
                          else:
                              return (m3u, url, r.status_code, False, None)
                      elif r.status_code >= 400 and r.status_code != 403:
                          return (m3u, url, r.status_code, False, None)
                      else:
                          return (m3u, url, r.status_code, True, None)
                  except Exception as e:
                      # Only retry on 404, otherwise fail immediately
                      if tries < max_retries - 1:
                          time.sleep(delay)
                          tries += 1
                          continue
                      return (m3u, url, None, False, str(e))
              return (m3u, url, 404, False, 'Max retries reached')

          for m3u in m3u_files:
              print(f'Checking {m3u}...')
              with open(m3u, encoding='utf-8') as f:
                  lines = f.readlines()
              # --- M3U format validation ---
              if not lines or not lines[0].strip().startswith('#EXTM3U'):
                  print(f'::error file={m3u}::Missing or invalid #EXTM3U header')
                  failed = True
              # Check for #EXTINF before each URL
              for i, line in enumerate(lines):
                  if line.strip().startswith('http'):
                      if not any('#EXTINF' in lines[j] for j in range(max(0, i-2), i)):
                          print(f'::error file={m3u},line={i+1}::URL without preceding #EXTINF: {line.strip()}')
                          failed = True
              # --- Collect URLs for concurrent link validation ---
              content = ''.join(lines)
              urls = url_pattern.findall(content)
              for url in urls:
                  link_checks.append((url, m3u))
                  url_to_file[url] = m3u

          # --- Concurrent link validation ---
          with ThreadPoolExecutor(max_workers=16) as executor:
              future_to_url = {executor.submit(check_url, url, m3u): (url, m3u) for url, m3u in link_checks}
              for future in as_completed(future_to_url):
                  url, m3u = future_to_url[future]
                  try:
                      m3u, url, status, ok, err = future.result()
                      if ok:
                          print(f'OK: {url} (status {status})')
                      else:
                          if status:
                              print(f'::error file={m3u}::Broken link: {url} (status {status})')
                          else:
                              print(f'::error file={m3u}::Error checking {url}: {err}')
                          failed = True
                  except Exception as e:
                      print(f'::error file={m3u}::Error in future: {e}')
                      failed = True
          if failed:
              sys.exit(1)
        shell: python
